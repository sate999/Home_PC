/* ============================================================
 * lsSort.c - ls | sort 파이프 구현 예제 (주석 있는 버전)
 * 
 * 기능: 쉘의 "ls -l | sort -k 5,5n" 명령을 파이프로 구현
 *       Child 1: ls -l 실행 → 파이프에 출력
 *       Child 2: 파이프에서 읽어서 → sort 실행
 * 컴파일: gcc -o lsSort lsSort.c
 * 실행: ./lsSort
 * 
 * 동작 원리:
 * - Child 1은 stdout을 파이프로 리다이렉트하여 ls 결과를 파이프에 씀
 * - Child 2는 stdin을 파이프로 리다이렉트하여 파이프에서 읽음
 * ============================================================ */

#include <stdio.h>      /* printf, fflush 함수 사용 */
#include <stdlib.h>     /* exit 함수 사용 */
#include <unistd.h>     /* pipe, fork, close, dup, read, execl 함수 사용 */
#include <sys/wait.h>   /* wait 함수 사용 */

char text[80];          /* 첫 줄 읽기용 버퍼 */

/* ============================================================
 * read2line 함수
 * - stdin(파이프)에서 한 줄을 읽어서 input 버퍼에 저장
 * - '\n'(개행문자)를 만나면 읽기 종료
 * ============================================================ */
void read2line (char *input) {
    while (1) {
        read (0, input, 1);         /* stdin에서 1바이트씩 읽기 */
        if (*input == '\n')         /* 개행문자면 종료 */
            break;
        else
            input++;                /* 다음 위치로 이동 */
    }
}

int main (int argc, char *argv[]) {
    int fd[2];
    
    /* --------------------------------------------------------
     * 파이프 생성
     * fd[0]: 읽기용 (Child 2가 사용)
     * fd[1]: 쓰기용 (Child 1이 사용)
     * -------------------------------------------------------- */
    if (pipe(fd) == -1) {
        perror(argv[0]);
        exit(1);
    }
    
    /* --------------------------------------------------------
     * 첫 번째 자식 프로세스 (ls -l 실행)
     * - stdout을 파이프의 쓰기 끝(fd[1])으로 리다이렉트
     * - ls -l 실행하면 결과가 파이프로 들어감
     * -------------------------------------------------------- */
    if (fork() == 0) {              /* first child */
        close (1);                  /* stdout 닫기 */
        dup (fd[1]);                /* fd[1]을 1번(stdout)으로 복제 */
        /* 이제 stdout(1)은 파이프의 쓰기 끝을 가리킴 */
        
        close (fd[0]);              /* 사용하지 않는 읽기 끝 닫기 */
        close (fd[1]);              /* 원본 fd[1] 닫기 (이미 dup됨) */
        
        printf ("ls display sorted\n");     /* 헤딩 출력 (파이프로 감) */
        fflush (stdout);            /* 버퍼 비우기 (중요!) */
        
        /* --------------------------------------------------------
         * execl로 ls 명령 실행
         * - 현재 프로세스가 ls로 대체됨
         * - ls의 출력은 파이프로 리다이렉트됨
         * -------------------------------------------------------- */
        execl ("/bin/ls", "ls", "-l", (char*) 0);
        exit (127);                 /* execl 실패 시에만 실행됨 */
    }
    
    /* --------------------------------------------------------
     * 두 번째 자식 프로세스 (sort 실행)
     * - stdin을 파이프의 읽기 끝(fd[0])으로 리다이렉트
     * - sort가 파이프에서 데이터를 읽어서 정렬
     * -------------------------------------------------------- */
    if (fork() == 0) {              /* second child */
        close (0);                  /* stdin 닫기 */
        dup (fd[0]);                /* fd[0]을 0번(stdin)으로 복제 */
        /* 이제 stdin(0)은 파이프의 읽기 끝을 가리킴 */
        
        close (fd[0]);              /* 원본 fd[0] 닫기 */
        close (fd[1]);              /* 사용하지 않는 쓰기 끝 닫기 */
        
        read2line (text);           /* 첫 줄("ls display sorted") 읽기 */
        printf ("\tHeading: %s\n", text);   /* 헤딩 출력 */
        fflush (stdout);
        
        /* --------------------------------------------------------
         * execl로 sort 명령 실행
         * - sort의 stdin은 파이프
         * - -k 5,5n: 5번째 필드(파일크기)로 숫자 정렬
         * -------------------------------------------------------- */
        execl ("/bin/sort", "sort", "-k", "5,5n", (char*) 0); 
        exit (127);
    }
    
    /* --------------------------------------------------------
     * 부모 프로세스
     * - 파이프 양쪽 모두 닫기 (자식들이 사용)
     * - 모든 자식 프로세스 종료 대기
     * -------------------------------------------------------- */
    close (fd[0]); 
    close (fd[1]);
    
    /* wait()가 -1 반환할 때까지 (모든 자식 종료) 대기 */
    while (wait((int*)0) != -1)
        ;
    
    exit(0);
}