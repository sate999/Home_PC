/* ============================================================
 * exercise1.c - 연습문제 1: 기본 파이프 통신 (주석 있는 버전)
 * 
 * 문제:
 * Pipe를 생성하여,
 * - Parent는 argv[1] 문자열을 pipe로 write하고
 * - Child는 pipe로부터 read하여, 읽은 내용을 화면에 출력하는
 * 프로그램을 작성하라. (dup를 사용하지 않고 작성하기)
 * 
 * 컴파일: gcc -o exercise1 exercise1.c
 * 실행: ./exercise1 "Hello World"
 * 
 * 출력 예시:
 * $ ./exercise1 "Hello World"
 * Hello World
 * ============================================================ */

#include <stdio.h>      /* printf 함수 사용 */
#include <stdlib.h>     /* exit 함수 사용 */
#include <unistd.h>     /* pipe, fork, read, write, close 함수 사용 */
#include <string.h>     /* strlen 함수 사용 */

#define BUFSIZE 256     /* 버퍼 크기 */

int main (int argc, char *argv[]) {
    int pipefd[2];      /* 파이프 파일 디스크립터 */
    int n;              /* read 반환값 (읽은 바이트 수) */
    char buf[BUFSIZE];  /* 읽기 버퍼 */
    
    /* 인자 검사 */
    if (argc < 2) {
        printf("Usage: %s <message>\n", argv[0]);
        exit(1);
    }
    
    /* --------------------------------------------------------
     * 파이프 생성
     * pipefd[0]: 읽기용 (자식이 사용)
     * pipefd[1]: 쓰기용 (부모가 사용)
     * -------------------------------------------------------- */
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(1);
    }
    
    /* --------------------------------------------------------
     * fork()로 자식 프로세스 생성
     * -------------------------------------------------------- */
    if (fork() == 0) {
        /* ====================================================
         * 자식 프로세스 (Child)
         * - 파이프에서 데이터를 읽어서 화면에 출력
         * ==================================================== */
        
        close (pipefd[1]);      /* 쓰기용 디스크립터 닫기 (사용 안함) */
        
        /* --------------------------------------------------------
         * 파이프에서 읽어서 화면에 출력
         * - read()가 양수 반환하는 동안 계속 읽기
         * - write(1, ...)으로 stdout에 출력
         * -------------------------------------------------------- */
        while ((n = read (pipefd[0], buf, BUFSIZE)) > 0)
            write(1, buf, n);   /* stdout(1)에 출력 */
        
        close(pipefd[0]);       /* 읽기용 디스크립터 닫기 */
        exit(0);
    }
    else {
        /* ====================================================
         * 부모 프로세스 (Parent)
         * - argv[1] 문자열을 파이프에 write
         * ==================================================== */
        
        close(pipefd[0]);       /* 읽기용 디스크립터 닫기 (사용 안함) */
        
        /* argv[1] 문자열을 파이프에 쓰기 */
        write(pipefd[1], argv[1], strlen(argv[1]));
        
        close(pipefd[1]);       /* 쓰기용 디스크립터 닫기 */
        /* 닫으면 자식의 read()가 0 반환하게 됨 */
    }
    
    return 0;
}