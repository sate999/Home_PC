/* ============================================================
 * create_pipe2.c - 파이프로 명령어 전달 후 실행 예제 (주석 있는 버전)
 * 
 * 기능: Child 2가 argv[1]을 파이프에 쓰고
 *       Child 1이 파이프에서 읽어서 해당 명령어를 execl로 실행
 * 컴파일: gcc -o create_pipe2 create_pipe2.c
 * 실행: ./create_pipe2 /bin/ls
 * 
 * 동작 원리:
 * - Child 2: argv[1]("/bin/ls")을 파이프에 write
 * - Child 1: 파이프에서 읽어서 execl로 실행
 * ============================================================ */

#include <stdio.h>          /* printf 함수 사용 */
#include <stdlib.h>         /* exit 함수 사용 */
#include <unistd.h>         /* pipe, fork, close, dup, read, execl 함수 사용 */
#include <string.h>         /* memset 함수 사용 */
#include <sys/types.h>      /* 타입 정의 */
#include <sys/wait.h>       /* wait 함수 사용 */

#define MAX_SIZE 50         /* 버퍼 최대 크기 */

int main (int argc, char *argv[]) { 
    int fd[2], pid=0, size=0, status=0;
    char buf[MAX_SIZE];
    
    /* 버퍼 초기화 */
    memset (buf, 0x00, MAX_SIZE);
    
    /* --------------------------------------------------------
     * 파이프 생성
     * fd[0]: 읽기용 (Child 1이 stdin으로 사용)
     * fd[1]: 쓰기용 (Child 2가 stdout으로 사용)
     * -------------------------------------------------------- */
    if ( pipe(fd) == -1 ) {
        perror("pipe() : ");
        exit(1);
    }
    
    /* --------------------------------------------------------
     * 첫 번째 자식 프로세스 (Child 1)
     * - stdin을 파이프 읽기 끝으로 리다이렉트
     * - 파이프에서 명령어 이름을 읽어서 execl로 실행
     * -------------------------------------------------------- */
    if ( fork() == 0 ) {            /* child 1 */
        close(0);                   /* stdin 닫기 */
        dup(fd[0]);                 /* fd[0]을 0번(stdin)으로 복제 */
        /* 이제 stdin(0)은 파이프의 읽기 끝을 가리킴 */
        
        close(fd[0]);               /* 원본 fd[0] 닫기 */
        close(fd[1]);               /* 사용하지 않는 쓰기 끝 닫기 */
        
        /* stdin(파이프)에서 명령어 경로 읽기 */
        size = read(0, buf, MAX_SIZE);
        
        /* --------------------------------------------------------
         * execl로 읽은 명령어 실행
         * - buf: 실행할 프로그램 경로 (예: "/bin/ls")
         * - 현재 프로세스가 해당 프로그램으로 대체됨
         * -------------------------------------------------------- */
        execl (buf, buf, (char *)NULL);
        
        /* execl 실패 시에만 아래 코드 실행 */
        perror ("execl() : ");
        exit(3);
    }
    
    /* --------------------------------------------------------
     * 두 번째 자식 프로세스 (Child 2)
     * - stdout을 파이프 쓰기 끝으로 리다이렉트
     * - argv[1]을 파이프에 출력
     * -------------------------------------------------------- */
    if ( fork() == 0 ) {            /* child 2 */
        close (1);                  /* stdout 닫기 */
        dup (fd[1]);                /* fd[1]을 1번(stdout)으로 복제 */
        /* 이제 stdout(1)은 파이프의 쓰기 끝을 가리킴 */
        
        close (fd[0]);              /* 사용하지 않는 읽기 끝 닫기 */
        close (fd[1]);              /* 원본 fd[1] 닫기 */
        
        /* argv[1]을 stdout(파이프)으로 출력 */
        printf ("%s", argv[1]);
        fflush (stdout);            /* 버퍼 비우기 (중요!) */
        
        exit(0);
    }
    
    /* --------------------------------------------------------
     * 부모 프로세스
     * - 파이프 양쪽 닫기
     * - 모든 자식 프로세스 종료 대기
     * -------------------------------------------------------- */
    close (fd[0]); 
    close(fd[1]);
    
    /* 모든 자식이 종료할 때까지 대기 */
    while ( wait(&status) != -1 )
        ;
    
    exit(0);
}